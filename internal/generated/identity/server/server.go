// Code generated by dbus-codegen-go DO NOT EDIT.
package identity

import (
	"context"
	"errors"
	"fmt"
	"github.com/godbus/dbus/v5"
	"github.com/godbus/dbus/v5/introspect"
)

var (
	// Introspection for de.telekomMMS.identity
	IntrospectDataIdentity = introspect.Interface{
		Name: "de.telekomMMS.identity",
		Methods: []introspect.Method{{Name: "GetStatus", Args: []introspect.Arg{
			{Name: "status", Type: "a{sv}", Direction: "out"},
		}},
			{Name: "ReLogin", Args: []introspect.Arg{}},
		},
		Signals: []introspect.Signal{{Name: "StatusChange", Args: []introspect.Arg{
			{Name: "status", Type: "a{sv}", Direction: "out"},
		}},
		},
		Properties: []introspect.Property{{Name: "Version", Type: "u", Access: "read"},
			{Name: "Status", Type: "a{sv}", Access: "read"},
		},
		Annotations: []introspect.Annotation{},
	}
)

// Signal is a common interface for all signals.
type Signal interface {
	Name() string
	Interface() string
	Sender() string

	path() dbus.ObjectPath
	values() []interface{}
}

// Emit sends the given signal to the bus.
func Emit(conn *dbus.Conn, s Signal) error {
	return conn.Emit(s.path(), s.Interface()+"."+s.Name(), s.values()...)
}

// ErrUnknownSignal is returned by LookupSignal when a signal cannot be resolved.
var ErrUnknownSignal = errors.New("unknown signal")

// LookupSignal converts the given raw D-Bus signal with variable body
// into one with typed structured body or returns ErrUnknownSignal error.
func LookupSignal(signal *dbus.Signal) (Signal, error) {
	switch signal.Name {
	case InterfaceIdentity + "." + "StatusChange":
		v0, ok := signal.Body[0].(map[string]dbus.Variant)
		if !ok {
			return nil, fmt.Errorf("prop .Status is %T, not map[string]dbus.Variant", signal.Body[0])
		}
		return &IdentityStatusChangeSignal{
			sender: signal.Sender,
			Path:   signal.Path,
			Body: &IdentityStatusChangeSignalBody{
				Status: v0,
			},
		}, nil
	default:
		return nil, ErrUnknownSignal
	}
}

// AddMatchSignal registers a match rule for the given signal,
// opts are appended to the automatically generated signal's rules.
func AddMatchSignal(conn *dbus.Conn, s Signal, opts ...dbus.MatchOption) error {
	return conn.AddMatchSignal(append([]dbus.MatchOption{
		dbus.WithMatchInterface(s.Interface()),
		dbus.WithMatchMember(s.Name()),
	}, opts...)...)
}

// RemoveMatchSignal unregisters the previously registered subscription.
func RemoveMatchSignal(conn *dbus.Conn, s Signal, opts ...dbus.MatchOption) error {
	return conn.RemoveMatchSignal(append([]dbus.MatchOption{
		dbus.WithMatchInterface(s.Interface()),
		dbus.WithMatchMember(s.Name()),
	}, opts...)...)
}

// Interface name constants.
const (
	InterfaceIdentity = "de.telekomMMS.identity"
)

// Identityer is de.telekomMMS.identity interface.
type Identityer interface {
	// GetStatus is de.telekomMMS.identity.GetStatus method.
	GetStatus() (status map[string]dbus.Variant, err *dbus.Error)
	// ReLogin is de.telekomMMS.identity.ReLogin method.
	ReLogin() (err *dbus.Error)
}

// ExportIdentity exports the given object that implements de.telekomMMS.identity on the bus.
func ExportIdentity(conn *dbus.Conn, path dbus.ObjectPath, v Identityer) error {
	return conn.ExportSubtreeMethodTable(map[string]interface{}{
		"GetStatus": v.GetStatus,
		"ReLogin":   v.ReLogin,
	}, path, InterfaceIdentity)
}

// UnexportIdentity unexports de.telekomMMS.identity interface on the named path.
func UnexportIdentity(conn *dbus.Conn, path dbus.ObjectPath) error {
	return conn.Export(nil, path, InterfaceIdentity)
}

// UnimplementedIdentity can be embedded to have forward compatible server implementations.
type UnimplementedIdentity struct{}

func (*UnimplementedIdentity) iface() string {
	return InterfaceIdentity
}

func (*UnimplementedIdentity) GetStatus() (status map[string]dbus.Variant, err *dbus.Error) {
	err = &dbus.ErrMsgUnknownMethod
	return
}

func (*UnimplementedIdentity) ReLogin() (err *dbus.Error) {
	err = &dbus.ErrMsgUnknownMethod
	return
}

// NewIdentity creates and allocates de.telekomMMS.identity.
func NewIdentity(object dbus.BusObject) *Identity {
	return &Identity{object}
}

// Identity implements de.telekomMMS.identity D-Bus interface.
type Identity struct {
	object dbus.BusObject
}

// GetStatus calls de.telekomMMS.identity.GetStatus method.
func (o *Identity) GetStatus(ctx context.Context) (status map[string]dbus.Variant, err error) {
	err = o.object.CallWithContext(ctx, InterfaceIdentity+".GetStatus", 0).Store(&status)
	return
}

// ReLogin calls de.telekomMMS.identity.ReLogin method.
func (o *Identity) ReLogin(ctx context.Context) (err error) {
	err = o.object.CallWithContext(ctx, InterfaceIdentity+".ReLogin", 0).Store()
	return
}

// GetVersion gets de.telekomMMS.identity.Version property.
func (o *Identity) GetVersion(ctx context.Context) (version uint32, err error) {
	err = o.object.CallWithContext(ctx, "org.freedesktop.DBus.Properties.Get", 0, InterfaceIdentity, "Version").Store(&version)
	return
}

// IdentityStatusChangeSignal represents de.telekomMMS.identity.StatusChange signal.
type IdentityStatusChangeSignal struct {
	sender string
	Path   dbus.ObjectPath
	Body   *IdentityStatusChangeSignalBody
}

// Name returns the signal's name.
func (s *IdentityStatusChangeSignal) Name() string {
	return "StatusChange"
}

// Interface returns the signal's interface.
func (s *IdentityStatusChangeSignal) Interface() string {
	return InterfaceIdentity
}

// Sender returns the signal's sender unique name.
func (s *IdentityStatusChangeSignal) Sender() string {
	return s.sender
}

func (s *IdentityStatusChangeSignal) path() dbus.ObjectPath {
	return s.Path
}

func (s *IdentityStatusChangeSignal) values() []interface{} {
	return []interface{}{s.Body.Status}
}

// IdentityStatusChangeSignalBody is body container.
type IdentityStatusChangeSignalBody struct {
	Status map[string]dbus.Variant
}
